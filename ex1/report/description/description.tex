\section{Development process and implementation}
\label{chap:development_process}

This chapter details the steps used during the development of the program. All of the development on the EFM32 was done in the computer lab 458 on the fourth floor of the Computer Science building (IT-bygget vest). Git was chosen as the version control system, mainly used together with GitHub. This meant we were not bound to work on the report inside of the lab.

The development environment for the EFM32 was already set up on the workstations in the lab and connected via USB to an EFM32GG-DK3750 development kit. There was a framework set up with a vector table and some subroutines, so all our resources was going towards solving the problem.

The assignment was part of a bigger compendium which contained a lot of useful information. This gave us a quick insight to the different tools that were avaibale to us, as well as an explanation of the problem we needed to solve.

Features of the program were added iteratively, beginning with simply getting the LEDs to light up and evolving to more sophisticated funcionality. The first iteration of the code simply turned on the LEDs. After this, an opening sequence was added to the program, the details of which and why it was added is explained more in section \ref{subsec:dev_pros_opening_seq}. Afterwards, a polling technique was used to test the buttons on the game pad. With the correct flags set a number will be written to a specific location in memory which indicates what buttons are being pressed. This number is then shifted eight places to the left to comply with the way LEDs are lightened up.

The next step was to make interrupts work. A main function was constructed to set the correct flags. When these are set the device goes to sleep and waits for an interrupt. A gpio handler was implemented to make sure we abort the interrupt as soon as possible, more on this later in section \ref{subsec:dev_pros_interrupts}.

\subsection{Setting up the LEDs}
\label{subsec:dev_pros_setup_led}

The LEDs is connected to the EFM32 through the GPIO. To enable the GPIO the clock needs to be enabled for the GPIO controller. The CMU is responsible for the clock and is fortunantly very easy to use. Register $CMU\_HFPERCLKEN0$ is a 32 bits register with each bit correponding to a specific IO controller. The GPIO controller is on the 13th bit, after that bit has been set to 1 the GPIO is ready for use.

\begin{lstlisting}
// C-eqvivalent:
// *CMU_HFPERCLKEN0 |= (1 << 13)
ldr r1, =CMU_BASE
ldr r2, [r1, #CMU_HFPERCLKEN0]
mov r3, #1
lsl r3, r3, #CMU_HFPERCLKEN0_GPIO
orr r2, r2, r3
str r2, [r1, #CMU_HFPERCLKEN0]
\end{lstlisting}

The GPIO has multiple connections and the game pad is connected so that button presses is registered on the C connection and what lights to light is read from the A connection. Following this the drive strength of the light is set on the A connection. This can take one of four values, each of which corresponds to a different AmpÃ¨re setting. Table \ref{tab:drive_strength} on page \pageref{tab:drive_strength} shows the different settings for drive strength.

\begin{table}
    \begin{center}
    \begin{tabular}{| l | l | l |}
        \hline
        Value   & Mode      & Description \\
        \hline
        0       & STANDARD  & 6 mA drive current \\
        \hline
        1       & LOWEST    & 0.5 mA drive current \\
        \hline
        2       & HIGH      & 20 mA drive current \\
        \hline
        3       & LOW       & 2 mA drive current \\
        \hline
    \end{tabular}
    \caption{Drive strength on the EFM32 GPIO}
    \label{tab:drive_strength}
    \end{center}
\end{table}

\subsection{Programming with interrupts}
\label{subsec:dev_pros_interrupts}

Interrupt support is implemented by first setting up the interrupt handlers.
Then, we activate the pins corresponding to the buttons by writing 0x22222222 to GPIO\_EXTIPSELL.
We further activate the External Interrupt Rising Edge Trigger, and the External Interrupt Falling Edge Trigger by writing 0xff to the GPIO\_EXTIRISE and GPIO\_EXTIFALL registers respectively.
Interrupt generation is enabled by writing 0xff to GPIO\_IEN.
To finally implement handling of interrupts, we set the two bits in ISER0 corresponding to our handler to 1. They are bit 1 and 11 in the register, resulting in the hexadecimal representation 0x802.

The first thing that the GPIO handler takes cares of is to clear the interrupt. If this is not done, the handler will be called again as if the buttons are still being pressed.

\subsection{Deep sleep}
\label{subsec:dev_pros_deep_sleep}

When interrupt handlers are implemented, the CPU is able to sleep when there is no processing to be done.
Deep sleep is a mode with a power consumption of only $1.1 \mu A$.
This is achieved by disabling the high-frequency oscillator, and instead using a lower-frequency one.
Many of the more power-consuming peripherals are also disabled in this mode.

To activate deep sleep mode we must set bit number 2 of the System Control Register to 1, as seen in figure \ref{figure:deep_sleep}

\begin{figure}[h!]
\begin{lstlisting}
ldr r2, =0x4
ldr r3, =SCR
str r2, [r3, #0]
\end{lstlisting}
\caption{Enabling deep sleep}
\label{figure:deep_sleep}
\end{figure}

Since we are working with interrupts, we also want the CPU to go back to sleep when an interrupt has been handled.
The System Control Register has a flag for this functionality as well, in bit number 1.
We therefore write 0x6 to the SCR to enable both deep sleep and sleep on exit (see figure \ref{figure:deep_sleep_on_exit}).

\begin{figure}[h!]
\begin{lstlisting}
ldr r2, =0x6
ldr r3, =SCR
str r2, [r3, #0]
\end{lstlisting}
\caption{Enabling both deep sleep and sleep on exit}
\label{figure:deep_sleep_on_exit}
\end{figure}
