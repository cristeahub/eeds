\section{Results and Tests}

As mentioned in the description section, we implemented two versions of this program; the first one using polling, where the computer has to check the status of the GPIO repeatedly, and the final version using interrupts, where the program may sleep between its tasks. The version running interrupts is, of course, expected to produce significantly less power consumptive results. Below follows test results for both programs, with a summarizing comparison at the end.

\subsection{Polling}

See figure \ref{fig:polling_io} in the appendices for the power consumption while using polling. The different stages of the program are marked as follows:

Boot sequence: 1.1
Running, no buttons pushed: 1.2
Running, alternating button-pushing: 1.3

Average current while idling: 3.51 mA.

\subsection{Interrupt}

Interrupts should result in a more energy-friendly power usage than polling. Below follows results for the two test.

\subsubsection{With energy mode 1}

See figure \ref{fig:interrupt_io} in the appendices for the power consumption while using intterrupts without deep sleep. The different stages of the program are marked as follows:

Boot sequence: 2.1
Running, no buttons pushed: 2.2
Running, alternating button-pushing: 2.3

Average current while idling: 1.19mA.

\subsubsection{With energy mode 2}

See figure \ref{fig:interrupt_io_deep_sleep} in the appendices for the power consumption while using interrupts with energy mode 2. The different stages of the program are marked as follows:

Boot sequence: 3.1
Running, no buttons pushed: 3.2
Running, alternating button-pushing: 3.3

Average current while idling: 2.17$\mu$A.

\subsection{Comparison}

See figure \ref{comparison} Appendix A for the comparison of the values.
